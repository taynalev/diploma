# -*- coding: utf-8 -*-
"""AIC_plot.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1qlKJFV01CJH6sdZ6lahCCpqaNVpZORF
"""

# здесь собраны импорты всех нужных библиотек, ненужные подчистила
# удобная библиотека для генерации словарей и проч
from collections import Counter
# основная функция для построения аппроксимаций
import scipy
from scipy.optimize import curve_fit
# матфункции, операции с массивами и проч
import numpy as np
from numpy import random
import random
# операции с таблицами
import pandas as pd
import csv
# для регулирования из командной строки
from optparse import OptionParser
from os import remove, chdir, system, getcwd, mkdir

# набор функций для посторения аппроксимаций
# для рандомного количества штаммов
# формула суммы трёх экспонент
def func_exp(x, a1, b1, a2, b2, a3, b3):
    return np.exp(x * a1 + b1) + \
           np.exp(x * a2 + b2) +  \
           np.exp(x * a3 + b3)

# фомула суммы двух степенных функций
# для рандомного количества штаммов
def func_pwr_r(x, a1, b1, a2, b2):
    ass = np.max(x) + 1
    return a1 * np.power(x + 1, b1) + \
           a2 * np.power(ass - x, b2)

# фомула суммы двух степенных функций
def func_pwr(x, a1, b1, a2, b2):
    return a1 * np.power(x + 1, b1) + \
            a2 * np.power(x_data.ndim - x, b2)

# статистические параметры аппроксимирования
def quality_metrics(array_observed,
                    array_predicted,
                    N_params):
    # проверяем всё ли ок с массивами
    N_points = len(array_observed)
    if len(array_observed) != len(array_predicted):
        raise ValueError
    # считаем статистические штуки
    sse = sum((array_observed - array_predicted)**2)
    AIC = 2*N_params + N_points*np.log(sse)
    BIC = N_params*np.log(N_points) + N_points*np.log(sse)
    rmsd = sse / len(array_observed)
    return [AIC, BIC, sse, rmsd]

# отбираем рандомное количество штаммов из выдачи протеинорто
def rand_strains(filename, numb_str):
    # читаем и создаём таблицу
    df = pd.read_csv(filename, sep="\t", engine='python')
    df = df.drop(['# Species', 'Genes', 'Alg.-Conn.'], axis=1)
    # на мясорубке нет пандаса для третьего питона
    # а на втором некоторые функции не работает, поэтому прописываем их ручками
    #  df = df.sample(n=numb_str)
    chosen_idx = np.random.choice(list(df.keys()), size=numb_str, replace=False)
    #  df = df.T
    #  df = df.iloc[chosen_idx]
    empty = {}
    for strain in chosen_idx:
        empty[strain] = df[strain]
    df = pd.DataFrame.from_dict(empty)
    # вытаскиваем рандомные штаммы и считаем ортологи
    lst_r = []
    df = df.replace('*', np.nan)
    df = pd.DataFrame(df).reset_index()
    for index, row in df.iterrows():
        count_nan = numb_str - row.isnull().sum().sum()
        lst_r.append(count_nan)
    dic_r = Counter(lst_r)
    lists_r = sorted(dic_r.items())
    # создаём массивы-координаты У-кривой
    x_r, y_r = zip(*lists_r)
    x_r = list(x_r)
    y_r = list(y_r)
    # обрезаем нули
    if len(x_r) > numb_str:
        x_r = x_r[-numb_str:]
        y_r = y_r[-numb_str:]
    strain_num1 = numb_str - 1
    if len(x_r) > strain_num1:
        x_r = x_r[-strain_num1:]
        y_r = y_r[-strain_num1:]
    for l in range(len(y_r)):
        y_r[l] = float(y_r[l]) / max(y_r)
    x_data_r = np.array(x_r)
    y_data_r = np.array(y_r)
    # аппроксимируем
    if type(x_data_r[0]) != str:
        popt_exp_r, pcov_r = curve_fit(func_exp, x_data_r, y_data_r, 
                                       p0=[1, -1, 1, -1, 1, -1])
        
    p0 = [1, -1, 1, -1]
    popt_pwr_r, pcov_r = curve_fit(func_pwr_r, x_data_r, y_data_r, p0)
    x_app_r = np.linspace(min(x_data_r), max(x_data_r))
    y_app_exp_r = func_exp(x_app_r, *popt_exp_r)
    # формируем массивы с координатами для аппроксимаций
    x_app_r = np.linspace(min(x_data_r), max(x_data_r))
    y_app_pwr_r = func_pwr_r(x_app_r, *popt_pwr_r)

    y_observed_r = y_data_r
    y_predicted_exp_r = func_exp(x_data_r, *popt_exp_r)
    y_predicted_pwr_r = func_pwr_r(x_data_r, *popt_pwr_r)
    N_params_exp_r = len(popt_exp_r)
    N_params_pwr_r = len(popt_pwr_r)
    # считаем статистические характеристики
    pwr_params = quality_metrics(y_data_r, y_predicted_pwr_r, N_params_pwr_r)
    exp_params = quality_metrics(y_data_r, y_predicted_exp_r, N_params_exp_r)
  
    """
    #plots! (for G func) 
    plt.scatter(x_r, y_r)
    plt.plot(x_app_r, y_app_exp_r, color = "r")
    plt.plot(x_app_r, y_app_pwr_r,color = "b")
    plt.show()
    """
    return x_data_r, y_data_r, popt_exp_r, pcov_r, pwr_params, exp_params

# функция для того, чтобы задавать параметры из командной строки
def main(nw_file_name, proteinortho, iterations, 
         max_numb, min_numb, out_file):
  
    with open("for_plots_100iter_fin.csv", "w") as file:
        headings = ['Number of random stains', 'Iteration number',
                    'X coord', 'Y coord',
                    'Exp params', 'Power params',
                    'AIC, BIC, sse, rmsd power func',
                    'AIC, BIC, sse,rmsd exp func']
        csv.writer(file).writerow(headings)
        
        for nmb_of_stains in range(int(min_numb), int(max_numb)):
            for k in range(int(iterations)):
                some_list = []
                some_list.append(nmb_of_stains)
                random_params = rand_strains(proteinortho, nmb_of_stains)
                some_list.append(k)
                for elemen in random_params:
                    some_list.append(elemen)
                csv.writer(file).writerow(some_list)


parser = OptionParser()
parser.add_option("-n", "--nw_file_name", help="New output file name")
parser.add_option("-p", "--proteinortho", help="Name of proteinortho file")
parser.add_option("-i", "--iterations", help="Number of iterations")
parser.add_option("-s", "--strains_numb", help="Needed strains number")
parser.add_option("-M", "--max_numb", help="Max strains number")
parser.add_option("-m", "--min_numb", help="Min stains number has to be >= 9")
parser.add_option("-d", "--out_file", help="Output file")
opt, args = parser.parse_args()


main(opt.nw_file_name, opt.proteinortho, 
     opt.iterations, opt.max_numb,
     opt.min_numb, opt.out_file)

'''
temp_lst = []

lilfile = open('approximation_params_random.csv', 'a+')
lilfile.write('try number', '/t', 'number of random stains', '/t',
              'x coord', '/t', 'y coord', '/t',
              'exp params', '/t', 'power params', '/n')
for try in range(10):
    lilfile.write(try, '/t')
    for i in range(8,86):
        lilfile.write(i, '/t')
        k = rand_strains('myproject.proteinortho', numb_str=i) 
        temp_lst.append(k)
lilfile.close()
'''
 
"""#  power_lst = []
#  expon_lst = []
for l in temp_lst:
    power_lst.append(l[0])
    expon_lst.append(l[1])

rall_power.append(sum(power_lst)/len(power_lst))
rall_exp.append(sum(expon_lst) / len(expon_lst))
print(rall_power, rall_exp)"""

"""FOR ORTOARSE"""

'''import subprocess
import optparse

reader = optparse.OptionParser()

reader.add_option('-i', '--interface',
                  dest = 'interface', help = 'Interface name')
reader.add_option('-n', '--new',
                  dest = 'new', help = 'New adress')

(values, keys) = reader.parse_args()
interface = values.interface
new = values.new
print('Changing adress of interface' + interfsce + ' to ' + new)

subprocess.call(['ifconfig', interface, 'down'])
subprocess.call(['ifconfig', interface, 'hw', 'ether', new])
subprocess.call(['ifconfig', interface, 'up'])'''

"""rall_power = []
rall_exp = []

for numb in range(30,86):
    def func_pwr_r(x, a1, b1, a2, b2):
      return a1 * np.power(x + 1, b1) + \
             a2 * np.power((numb + 1) - x, b2)

    temp_lst = []
    for i in range(50):
        k = rand_strains('myproject.proteinortho', numb_str=numb) 
        temp_lst.append(k)
        
    power_lst = []
    expon_lst = []
    for l in temp_lst:
        power_lst.append(l[0])
        expon_lst.append(l[1])

    rall_power.append(sum(power_lst)/len(power_lst))
    rall_exp.append(sum(expon_lst) / len(expon_lst))
    print(rall_power, rall_exp)

id_list = []
for num in range(30, 82): 
    id_list.append(num)

df_random_plot = pd.DataFrame(list(zip(rall_power, rall_exp, id_list)),
               columns=['Power func AIC', 'Exp func AIC', 'ID']) 
df_random_plot = df_random_plot.set_index('ID')
df_random_plot

df_random_plot['Diff'] = df_random_plot['Power func AIC'] - df_random_plot['Exp func AIC']

df_random_plot

import seaborn as sns
sns.set()

sns.set(style="whitegrid")

sns.lineplot(data=df_random_plot, palette="tab10")

df = pd.read_csv('myproject.proteinortho', sep="\t", engine='python')
df = df.drop(['# Species', 'Genes', 'Alg.-Conn.'], axis=1)
df = df.T
df = df.sample(n=30)

df.shape
"""

